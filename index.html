<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano Key Detector Game</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        .piano {
            display: flex;
            position: relative;
            width: 100%;
            max-width: 1200px;
            height: 200px;
            margin: 20px auto;
            border: 2px solid #000;
            background-color: #fff;
            overflow-x: auto;
        }
        .key {
            position: relative;
            flex: 1;
            border: 1px solid #000;
            box-sizing: border-box;
            transition: background-color 0.3s;
        }
        .white {
            height: 100%;
            background-color: white;
            color: black;
            z-index: 1;
        }
        .black {
            position: absolute;
            width: 50%;
            height: 60%;
            background-color: black;
            color: white;
            z-index: 2;
            left: 75%;
            transform: translateX(-50%);
        }
        .active {
            background-color: #4CAF50 !important;
        }
        .key-label {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-500 via-purple-500 to-pink-500 min-h-screen flex flex-col items-center justify-center p-4">
    <h1 class="text-4xl font-bold text-white mb-6">Piano Key Detector Game</h1>
    <div class="flex flex-col items-center space-y-4 mb-4">
        <div class="flex space-x-4">
            <button id="toggleButton" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-6 rounded-lg transition duration-300">Start Detection</button>
            <button id="clearButton" class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-3 px-6 rounded-lg transition duration-300">Clear</button>
        </div>
        <div id="detectedNote" class="text-2xl font-semibold text-white">Detected Note: None</div>
        <div id="pianoKeyboard" class="piano"></div>
        <div id="errorMessage" class="text-red-300 text-center max-w-md"></div>
    </div>

    <script>
        if (!window.AudioContext && !window.webkitAudioContext) {
            const errorMsg = 'Web Audio API not supported. Use Edge, Chrome, or Firefox.';
            document.getElementById('errorMessage').textContent = errorMsg;
            document.getElementById('toggleButton').disabled = true;
            console.error(errorMsg);
        } else {
            let audioContext = null;
            let analyser = null;
            let source = null;
            let isAnalyzing = false;
            const button = document.getElementById('toggleButton');
            const clearButton = document.getElementById('clearButton');
            const detectedNoteDiv = document.getElementById('detectedNote');
            const errorDiv = document.getElementById('errorMessage');
            const pianoKeyboard = document.getElementById('pianoKeyboard');
            let currentNote = null;

            // Generate piano notes and frequencies (A0 = 27.5 Hz to C8 = 4186 Hz)
            const notes = [];
            const noteNames = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
            for (let octave = 0; octave <= 8; octave++) {
                noteNames.forEach((name, index) => {
                    if (octave === 0 && index < 3) return; // A0 start
                    if (octave === 8 && index > 3) return; // C8 end
                    notes.push(`${name}${octave}`);
                });
            }
            const frequencies = notes.map((note, i) => 27.5 * Math.pow(2, i / 12)); // A0 = 27.5 Hz

            // Create piano keyboard UI
            function createPianoKeys() {
                let whiteKeyIndex = 0;
                notes.forEach((note, index) => {
                    const isBlack = note.includes('#');
                    const key = document.createElement('div');
                    key.classList.add('key', isBlack ? 'black' : 'white');
                    key.dataset.note = note;
                    key.dataset.index = index;
                    const label = document.createElement('div');
                    label.classList.add('key-label');
                    label.textContent = note;
                    key.appendChild(label);
                    if (!isBlack) {
                        key.style.flex = '1';
                        whiteKeyIndex++;
                    }
                    pianoKeyboard.appendChild(key);
                });
            }
            createPianoKeys();

            async function checkMicPermission() {
                try {
                    const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
                    if (permissionStatus.state === 'denied') {
                        const errorMsg = 'Microphone access denied. Go to browser settings > Privacy > Microphone.';
                        errorDiv.textContent = errorMsg;
                        console.error(errorMsg);
                        return false;
                    } else if (permissionStatus.state === 'prompt') {
                        console.log('Requesting microphone permission...');
                        errorDiv.textContent = 'Please allow microphone access when prompted.';
                    }
                    return true;
                } catch (err) {
                    const errorMsg = 'Error checking microphone permission: ' + err.message;
                    errorDiv.textContent = errorMsg;
                    console.error(errorMsg);
                    return false;
                }
            }

            // Autocorrelation pitch detection
            function detectPitch(buffer, sampleRate) {
                const SIZE = buffer.length;
                const MAX_SAMPLES = Math.floor(SIZE / 2);
                const MIN_SAMPLES = 2;
                let bestOffset = -1;
                let bestCorrelation = 0;
                let rms = 0;
                let foundGoodCorrelation = false;
                let correlations = new Array(MAX_SAMPLES);

                for (let i = 0; i < SIZE; i++) {
                    rms += buffer[i] * buffer[i];
                }
                rms = Math.sqrt(rms / SIZE);
                if (rms < 0.01) return null; // Too quiet

                let lastCorrelation = 1;
                for (let offset = MIN_SAMPLES; offset < MAX_SAMPLES; offset++) {
                    let correlation = 0;
                    for (let i = 0; i < SIZE - offset; i++) {
                        correlation += Math.abs(buffer[i] * buffer[i + offset]);
                    }
                    correlation = correlation / SIZE;
                    correlations[offset] = correlation;
                    if ((correlation > 0.2) && (correlation > lastCorrelation)) {
                        foundGoodCorrelation = true;
                        if (correlation > bestCorrelation) {
                            bestCorrelation = correlation;
                            bestOffset = offset;
                        }
                    } else if (foundGoodCorrelation) {
                        // Parabolic interpolation for better accuracy
                        const shift = (correlations[bestOffset + 1] - correlations[bestOffset - 1]) / (2 * correlations[bestOffset]);
                        return sampleRate / (bestOffset + shift);
                    }
                    lastCorrelation = correlation;
                }
                if (bestCorrelation > 0.01) {
                    return sampleRate / bestOffset;
                }
                return null;
            }

            function frequencyToNote(frequency) {
                if (!frequency) return null;
                let closestIndex = 0;
                let minDiff = Infinity;
                frequencies.forEach((freq, index) => {
                    const diff = Math.abs(frequency - freq);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIndex = index;
                    }
                });
                return notes[closestIndex];
            }

            function highlightKey(note) {
                if (currentNote) {
                    const prevKey = document.querySelector(`[data-note="${currentNote}"]`);
                    if (prevKey) prevKey.classList.remove('active');
                }
                currentNote = note;
                if (note) {
                    const key = document.querySelector(`[data-note="${note}"]`);
                    if (key) key.classList.add('active');
                    detectedNoteDiv.textContent = `Detected Note: ${note}`;
                } else {
                    detectedNoteDiv.textContent = 'Detected Note: None';
                }
            }

            async function startAnalysis() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    source = audioContext.createMediaStreamSource(stream);
                    source.connect(analyser);
                    isAnalyzing = true;
                    button.textContent = 'Stop Detection';
                    console.log('Started pitch detection...');
                    errorDiv.textContent = '';
                    const buffer = new Float32Array(analyser.fftSize);
                    function analyze() {
                        if (!isAnalyzing) return;
                        analyser.getFloatTimeDomainData(buffer);
                        const pitch = detectPitch(buffer, audioContext.sampleRate);
                        const note = frequencyToNote(pitch);
                        highlightKey(note);
                        requestAnimationFrame(analyze);
                    }
                    analyze();
                } catch (err) {
                    const errorMsg = 'Error starting pitch detection: ' + err.message;
                    errorDiv.textContent = errorMsg;
                    console.error(errorMsg);
                }
            }

            function stopAnalysis() {
                if (source) source.disconnect();
                if (audioContext) audioContext.close();
                isAnalyzing = false;
                button.textContent = 'Start Detection';
                console.log('Stopped pitch detection.');
                highlightKey(null);
            }

            async function toggleAnalysis() {
                if (isAnalyzing) {
                    stopAnalysis();
                } else {
                    const hasPermission = await checkMicPermission();
                    if (hasPermission) {
                        startAnalysis();
                    }
                }
            }

            button.onclick = toggleAnalysis;

            clearButton.onclick = () => {
                highlightKey(null);
                errorDiv.textContent = '';
            };
        }
    </script>
</body>
</html>
